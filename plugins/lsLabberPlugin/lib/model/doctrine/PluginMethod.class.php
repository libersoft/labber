<?php

/**
 * This abstract class Pluginhas been auto-generated by the Doctrine ORM Framework
 */
abstract class PluginMethod extends BaseMethod
{
  /**
   * Rigenera i controlli ad ogni salvataggio del metodo.
   */
  public function save(Doctrine_Connection $conn = null)
  {
    parent::save($conn);
    $this->updateDeterminationTypes();
  }

  public function hasField(FieldType $fieldType)
  {
    // Ritorna subito false se non esiste il FieldType
    if (!$fieldType)
    {
      return false;
    }

    $this->refreshRelated('Fields');

    foreach ($this->getFields() as $field)
    {
      if ($field === $fieldType)
      {
        return true;
      }
    }

    return false;
  }

  public function postInsert($event)
  {
    if ($this->um_id)
    {
      $mum = new MethodUnitOfMeasurement();
      $mum->method_id = $this->id;
      $mum->unit_of_measurement_id = $this->um_id;
      $mum->is_default = true;
      $mum->save();
    }
  }

  public function getMatrices()
  {
    $dc = new Doctrine_Collection('Matrix');
    $dc->setData($this->getAssociatedMatrixes());
    return $dc;
  }

  private function _initializeField($slug, $value, $dt)
  {
    $fieldType = Doctrine_Query::create()
      ->from('FieldType')
      ->where('slug = ?', $slug)
      ->fetchOne();

    // controllo se il parametro è associato al metodo
    if (!$this->hasField($fieldType))
    {
      $field = new MethodField();
      $field->setMethod($this);
      $field->setFieldType($fieldType);
      $field->save();
    }

    // associo il parametro al tipo di controllo
    $dtf = new DeterminationTypeField();
    $dtf->setFieldType($fieldType);
    $dtf->setDeterminationType($dt);
    $dtf->setValue($value);
    $dtf->setIsDefault(true);
    $dtf->save();
  }

  public function updateDeterminationTypes()
  {
    // cancello tutte i determination type che sono anteprima di questo metodo
    $deleteQuery = Doctrine_Query::create()
      ->delete('DeterminationType d')
      ->where('d.method_id = ?', $this->id)
      ->andWhere('d.is_preview = ?', true);
    $deleteQuery->execute();

    $denominations = $this->getDenominations()->getPrimaryKeys();
    // questa relazione prende la refClass, usare matrix_id come identifier
    $matrixes = $this->getMatrixes();

    // creo un controllo per ogni coppia matrice/analita
    foreach ($matrixes as $matrix)
    {
      foreach ($denominations as $denomination)
      {
        $determinationType = new DeterminationType();
        $determinationType->method_id = $this->id;
        $determinationType->days = $this->days;
        $determinationType->price = $this->cost;
        $determinationType->um_id = $this->um_id;
        $determinationType->scale_id = $this->prefix_id;
        $determinationType->significant_digits = $this->significant_digits;
        $determinationType->max_decimal_digits = $this->max_decimal_digits;
        $determinationType->denomination_id = $denomination;
        $determinationType->matrix_id = $matrix->matrix_id;

        // associo e valorizzo LOQ e LOD se sono stati specificati
        $this->loq && $this->_initializeField('loq', $this->loq, $determinationType);
        $this->lod && $this->_initializeField('lod', $this->lod, $determinationType);

        // associo al controllo le costanti del metodo
        foreach ($this->getConstants()->getPrimaryKeys() as $methodConstant)
        {
          $determinationTypeConstant = new DeterminationTypeMethodConstant();
          $determinationTypeConstant->method_constant_id = $methodConstant;
          $determinationTypeConstant->setDeterminationType($determinationType);
          $determinationTypeConstant->save();
        }
        $determinationType->save();
      }
    }

    foreach ($this->getRules() as $rule)
    {
      $q = Doctrine_Query::create()
        ->from('DeterminationType d')
        ->where('d.method_id = ?', $this->id)
        ->andWhere('d.is_preview = ?', true);

      // vedo a quali matrici la devo applicare
      // filtro solo se non sono tutte
      $matrixIds = json_decode($rule->matrix_ids, true);
      if ($matrixIds != 'all')
      {
        $q->andWhereIn('d.matrix_id', $matrixIds);
      }

      // vedo a quali denominazioni la devo applicare
      // filtro solo se non sono tutti
      $denominationIds = json_decode($rule->denomination_ids, true);
      if ($denominationIds != 'all')
      {
        $q->andWhereIn('d.denomination_id', $denominationIds);
      }

      switch ($rule->action)
      {
        // questa regola assegna i valori ai parametri del controllo
        case 'set-field-values':
          // questa regola contiene un ID di FieldType e un array di valori che
          // può assumere
          $ruleValue = json_decode($rule->getValue(), true);
          $fieldTypeId = $ruleValue['field-id'];
          $fieldValues = $ruleValue['field-values'];

          // la query ritorna tutte le DeterminationType interessate alla regola
          foreach ($q->execute() as $determinationType)
          {
            foreach ($fieldValues as $fieldValue)
            {
              $detTypeField = new DeterminationTypeField();
              $detTypeField->field_type_id = $fieldTypeId;
              $detTypeField->setDeterminationType($determinationType);
              // setta il parametro preferito se è l'unico valore
              $detTypeField->is_default = count($fieldValues) === 1;

              $this->parseFieldValue($detTypeField, $fieldValue);

              $detTypeField->save();
            }
          }
          break;

        // valorizzo una costante ad un certo valore
        case 'set-constant-value':
          $ruleValue = json_decode($rule->getValue(), true);

          foreach ($q->execute() as $determinationType)
          {
            $q = Doctrine_Query::create()
              ->from('DeterminationTypeMethodConstant dtm')
              ->where('dtm.determination_type_id = ?', $determinationType->id)
              ->andWhere('dtm.method_constant_id = ?', $ruleValue['constant-id']);

            $determinationTypeMethodConstant = $q->fetchOne();

            if ($determinationTypeMethodConstant)
            {
              $determinationTypeMethodConstant->value = $ruleValue['constant-value'];
              $determinationTypeMethodConstant->save();
            }
          }
          break;

        // modifico i dati di queste determinazioni
        case 'change-um':
          $ruleValue = json_decode($rule->getValue(), true);

          foreach ($q->execute() as $determinationType)
          {
            foreach ($ruleValue as $k => $v)
            {
              switch ($k)
              {
                case 'loq':
                case 'lod':
                  // prende il FieldType di LOQ o LOD
                  $fieldType = Doctrine_Query::create()
                    ->from('FieldType')
                    ->where('slug = ?', $k)
                    ->fetchOne();

                  // se è associato al Method, setta il valore come default
                  if ($v !== '' && $this->hasField($fieldType))
                  {
                    $detTypeField = $determinationType->getField($fieldType);
                    $detTypeField->is_default = true;
                    $detTypeField->value = $v;
                    $detTypeField->save();
                  }
                  break;
                case 'si-prefix-id':
                  $determinationType->set('scale_id', $v);
                  break;
                default:
                  $determinationType->set(str_replace('-', '_', $k), $v);
              }
            }

            $determinationType->save();
          }
          break;

        // setto come predefinito questo metodo per questa determinazione
        case 'set-default':
          foreach ($q->execute() as $determinationType)
          {
            $determinationType->is_default = true;
            $determinationType->save();
          }
          break;

        // setto questo tipo di determinazione come accreditato Sinal
        case 'set-certified':
          foreach ($q->execute() as $determinationType)
          {
            $determinationType->is_sinal = true;
            $determinationType->save();
          }
          break;

        // setto il modificatore di costo
        case 'set-price':
          $value = json_decode($rule->getValue(), true);

          foreach ($q->execute() as $determinationType)
          {
            $determinationType->price = $value;
            $determinationType->save();
          }
          break;

        case 'disable':
          $q = Doctrine_Query::create()
            ->delete('DeterminationType d')
            ->where('d.method_id = ?', $this->id)
            ->andWhere('d.is_preview = ?', true);

          $matrixIds = json_decode($rule->getMatrixIds(), true);
          if ($matrixIds != 'all')
          {
            $q->andWhereIn('d.matrix_id', $matrixIds);
          }

          $denominationIds = json_decode($rule->getDenominationIds(), true);
          if ($denominationIds != 'all')
          {
            $q->andWhereIn('d.denomination_id', $denominationIds);
          }

          $q->execute();
          break;

        // imposta i valori e le concentrazioni di incertezza e recupero
        case 'set-uncertainty-recovery':
          $ruleValue = json_decode($rule->getValue(), true);

          foreach ($q->execute() as $determinationType)
          {
            foreach ($ruleValue as $k => $v)
            {
              // usa la chiave dell'array del valore della regola
              // che è lo slug della costante
              $q = Doctrine_Query::create()
                ->from('DeterminationTypeMethodConstant dtm')
                ->leftJoin('dtm.MethodConstant mc')
                ->where('dtm.determination_type_id = ?', $determinationType->id)
                ->andWhere('mc.slug = ?', $k);

              $determinationTypeMethodConstant = $q->fetchOne();

              // la costante dev'essere stata precedentemente associata!
              if ($determinationTypeMethodConstant)
              {
                $determinationTypeMethodConstant->value = $v;
                $determinationTypeMethodConstant->save();
              }
            }
          }
          break;

        case 'multiset':
          $ruleValue = json_decode($rule->getValue(), true);

          foreach ($q->execute() as $determinationType)
          {
            foreach ($ruleValue as $k => $v)
            {
              switch ($k)
              {
                case 'loq':
                case 'lod':
                  $fieldType = Doctrine_Query::create()
                    ->from('FieldType')
                    ->where('slug = ?', $k)
                    ->fetchOne();

                  if ($v !== '' && $this->hasField($fieldType))
                  {
                    $detTypeField = $determinationType->getField($fieldType);
                    $detTypeField->is_default = true;
                    $detTypeField->value = $v;
                    $detTypeField->save();
                  }
                  break;
                // Incertezza e Recupero multipli
                case (substr($k, -7) === 'livello'):
                  $q = Doctrine_Query::create()
                    ->from('DeterminationTypeMethodConstant dtm')
                    ->leftJoin('dtm.MethodConstant mc')
                    ->where('dtm.determination_type_id = ?', $determinationType->id)
                    ->andWhere('mc.slug = ?', $k);

                  if ($determinationTypeMethodConstant = $q->fetchOne())
                  {
                    $determinationTypeMethodConstant->value = $v;
                    $determinationTypeMethodConstant->save();
                  }
                  break;
                case 'si-prefix-id':
                  $determinationType->set('scale_id', $v);
                  break;
                default:
                  $determinationType->set(str_replace('-', '_', $k), $v);
              }
            }

            $determinationType->save();
          }
          break;
      }
    }
  }

  // Setta il valore di default o non-SINAL
  private function parseFieldValue($detTypeField, $fieldValue)
  {
    switch (substr($fieldValue, -1))
    {
      case '!':
        $detTypeField->is_default = true;
        $this->parseFieldValue($detTypeField, substr($fieldValue, 0, -1));
        break;
      case '*':
        $detTypeField->is_sinal = false;
        $this->parseFieldValue($detTypeField, substr($fieldValue, 0, -1));
        break;
      default:
        $detTypeField->value = $fieldValue;
    }
  }

  public function getAssociatedFields()
  {
    $mfs = $this->getFields();
    $fields = array();

    foreach ($mfs as $mf)
    {
      $fields[] = $mf->getFieldType();
    }

    return $fields;
  }

  public function getAssociatedDenominations()
  {
    $mds = $this->getDenominations();
    $denominations = array();

    foreach ($mds as $md)
    {
      $denominations[] = $md->getDenomination();
    }

    return $denominations;
  }

  public function getAssociatedMatrixes()
  {
    $mms = $this->getMatrixes();
    $matrixes = array();

    foreach ($mms as $mm)
    {
      $matrixes[] = $mm->getMatrix();
    }

    return $matrixes;
  }

  public function getReportColumnsAsJson()
  {
    $result = array();
    $reportColumns = $this->getReportColumns();
    foreach ($reportColumns as $reportColumn)
    {
      $result[] = array('column_id' => $reportColumn->id, 'value' => '');
    }
    return json_encode($result);
  }



  public function getInitialFormulaState()
  {
    $q = Doctrine_Query::create()
    ->from('FormulaState fs')
    ->where('fs.method_id = ?', $this->id)
    ->andWhere('fs.is_initial = ?', true)
    ;

    $formulaState = $q->fetchOne();

    if(!$formulaState)
    {
      $q = Doctrine_Query::create()
      ->from('FormulaState fs')
      ->where('fs.method_id = ?', $this->id)
      ;
      $formulaState = $q->fetchOne();
    }

    return $formulaState;

  }
}